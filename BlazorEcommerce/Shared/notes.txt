-- To seed data in any new table, go to data context and add the dummy data using HasData method of 
modelBuilder.
After that add the migration, by running the command- dotnet ef migrations add <Mig name (any)> in
PM console
Then add the changes (adding seed data) by running dotnet ef database update

--Making a new api for a model
-ADD a <EntityName>Service folder in Services folder, and add interface I<EntityName>Service
and its implementation class <EntityName>Service files in it
-add the method signatures (eg getAllProducts, getProductById,etc) to interface
-implement the interface in implementation file. Inject data context here to get access to db
-Register this service in Program.cs using AddScoped
-Create a controller <EntityName>Controller, and inject the interface in it, to get access to its methods
-call the methods in the endpt wrapper functions. (forwarding client request to service)


--fetching products by category on lcient side and displaying them
- we change the method signature of GetProducts in which we now pass an arg categoryUrl,
which is set to null by default. We also add an event ProductsChanged in the IProductService
and invoke it whenever a api request is made (GetProducts call)
-In ProductService, in GetProducts, if categoryUrl is null we fetch all products else we fetch
products according to categoryUrl

flow-												ProductsChanged invoked and products fetched
Index page (GetProducts called from ProductService) -------------------------------------------->
													Whenever homepage(/) or category page(/{categoryUrl})

ProductsChanged event invokation is notified to all the subscribers (ProductList) of the events's 
service (ProductService). 
State.Onchange += HandleChange is how the subscribers call the appropriate method (HandleChange) when
the event (OnChange) is invoked
Here, ProductService.ProductsChanged += StateHasChanged. StateHasChanged is an inbuilt function which
notifies the base component (ProductList) that state has changed (products) and causes it o re-render it
https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/events/how-to-subscribe-to-and-unsubscribe-from-events

--Go from Home to books
-products set to (all) in Home
-We go to /books so categoryUrl set to books and products which are books are fetched using ProductService 
-products set to (books) but page still displays all products, since productList doesn't know yet
-The event ProductsChanged is invoked and ProductList is notified
-ProductList calls StateHasChanged on being notified and hence is re-rendered displaying new list
of products (which are books)

--Search
-Server : 
-Add the SearchProducts method signature to IProductSevice, implement it in ProductService
-Add a Get route search/{searchText} to ProductController 

--SearchRecommendation
-Server : 
-Add the GetProductSearchSuggestions method signature to IProductSevice, implement it in ProductService
which returns a serviceresponse of a list of strings (instead of products) to autocomplete
									 ---------------
-Add a Get route seacrhSuggestions/{searchText} to ProductController 

-in frontend add methods for both of these in IProductService
-Implement both in ProductService
-SearchProducts will make an api call to $"api/product/search/{searchText}" and update 
Products, and invoke products changed
-GetProductSearchSuggestions will simply make an api call to $"api/product/searchSuggestions/{searchText}"
and return the data from result

-make a route for search page in index page "/search/{searchText}", if searchText is not
null call SearchProducts method to update the displayed products
-so that users can search products from url

--creating a search component
-inject ProductService and NavigationManager (to redirect to some other page)
-bind listens to OnChange event only
-with bind-value we can assign a custon event to listen to
-in input field the list name should match with the id of datalist component
-add the search component to layout

--creating a new layout
-create shared layout component and change the DefaultLayout and Layout in App.razor

--featured products
-add a new boolean column featured to products table, set default to false
-seed data again by updating some products in hasData with featured set as true
-backend
-add method signature to get featured products in IProductService and implement it in 
ProductService
-make a route "/featured" in ProductController
-frontend
-add method signature to get featured products in IProductService and implement it in 
ProductService (where you get it from api and return the products)
-display the featured products in its own shared component
-render the shared component in index page

--DTO (Data transfer objects)
-To return selected fields of a model, instead of all the fields
-We can also add other information with the selected fields

--Pagination in search results
-backend
-We make a new DTO class, ProductSearchResultDTO with a list of products, total pages, 
current page
-In IProductService we change the return type of SearchProducts to ProductSearchResultDTO 
instead of just a list of products, and add page as an argument
-Update its implementation in ProductService
-Update route in product controller to search/{searchText}/{page} where default value of page = 1

-frontend
-in IProductService add the fields currentPage, pageCount, lastSearchText, add arg
page to SearchProducts
-in productService initialize currentPage to 1, pageCount to 0, lastSearchText to empty string
-Update SearchProducts implementation and set currentPage, pageCount, lastSearchText based
on response, so that we can display pages in ProductList
-In index.razor update searchText route with page as parameter
-In search component set the request url to $"search/{searchText}/1" (default search result page)
-pass search = true as param to ProductList if it is a search page in index
-In productList, if it is a searchList then render buttons for total pages (pageCount 
set in productService on SearchProducts call) which point to /search/@ProductService.LastSearchText/@i
where i is the button / page number
-Outline the button if its number is same as currentPage

--cart using local storage 
-add Blazored.LocalStorage nuget package in client project
-add the BlazoredLocalStorage service to app in program.cs 
-also add the using Blazored.LocalStorage directive in _imports to use it in client globally
-add CartCounter component, and display it next to Search
-Make a CartItem model in backend with properties ProductId and ProductTypeId (All other
info regarding the item can be gathered in server with these 2 props)

-client
-add CartService which will add items to local storage and read items from local storage
-contains an event OnChange so that whenever cart updated, we can invoke it; method
to add item to cart, get all items from cart (localstorage)
-In implementation class we inject local storage in ctor, and implement the methods

-Make an add to cart button in ProductDetails page which takes the selected productVariant 
(GetSelectedVariant()), converts it into a cartItem and stores it in localStorage using
CartService

-Now when we add product to cart we want to update productCount in topbar cart
So CartCounter needs to subscribe to CartService, listen to the event OnChange starting when
CartCounter is initialized -> rerender component when OnChange is invoked
-Add method to get cart items count to display in CartCounter

--Turn cartitems into products (with selected fields using CartProductResponeDTO)
though api endpt
-create a CartProductResponeDTO and add all the properties to show
-create a cartservice in backend
-add method signature of the method to convert cartitems to CartProductDTOs in ICartService
which accepts list of cartitems as input
-create a CartController to make a POST api endpoint for this service method
-make a method GetCartProducts in the client ICartService, no need to add arg
List<CartItem> in the signature, as we can access them from localstorage
-implement the post api call to /api/cart/product in the method implementation

-adding a method in client CartService to remove item from cart (local storage)
-since we store item in localStorage by productId and productTypeId of item, it only makes
sense to pass those as arguments to Remove method
-add delete button in CartPage, add onclick method which calls removeProductFromCart with the
parameters

-add quantity field to CartItem model and Cart
-in server CartService add the quantity field wherever CartProductResponseDTO is created
-make changes in client CartService addToCart method 

-Update item quantity in cart
-add method UpdateQuantity in client ICartService which accepts CartProductResponseDTO
as input (since it is displayed in cart page) and sets the quantity of product ans input's quantity

-add input field for quantity in cart for each product
-onchange i input field, parse the ChangeEventArgs and get its integer value, and update 
product quantity, update the quantity in localstorage using cartService